# "Упрощенный облачный диск" (Simple Cloud Drive)

Пользователи загружают файлы, получают к ним доступ по ссылкам, а система управляет метаданными и перенаправляет запросы на скачивание.

##Запуск

1. Запустить клиент Docker.
2. Открыть корневую папку в терминале.
3. Выполнить <code>docker-compose -f docker-compose.yml up --build</code>
4. API доступен по адресу http://localhost:5000, микросервисы - по портам 5001, 5002 и 5003.

## 4 микросервиса + Yarp в качестве единой точки входа (API Gateway):

1. API Gateway (Yarp): Единый вход для всех клиентских запросов.
2. Auth Service: Регистрация, аутентификация, выдача JWT-токенов.
3. File Metadata Service: Управление метаданными файлов (название, размер, владелец, дата загрузки). Хранится в PostgreSQL.
4. File Storage Service: Непосредственная загрузка, хранение и выдача файлов. Хранилище — локальная файловая система или Azure Blob Storage / AWS S3 для реализма.

## Технологический стек и их применение:

Технология Применение в проекте
ASP.NET Core Фреймворк для создания всех микросервисов (Web API).
Yarp API Gateway для маршрутизации запросов к нужному сервису. Ключевая фича: будет проксировать запросы на скачивание файлов напрямую в File Storage Service, минуя основной бэкенд.
RabbitMQ Для асинхронной связи между сервисами. Например, после загрузки файла Auth Service отправляет событие в RabbitMQ, а File Metadata Service его обрабатывает для записи в БД.
gRPC Для быстрой и эффективной связи между внутренними сервисами, которым нужна низкая задержка (например, между Gateway и Auth Service для валидации токена).
Redis Кеширование метаинформации о часто запрашиваемых файлах. Кеширование JWT-токенов или их blacklist для быстрого логаута.
PostgreSQL Основное надежное хранилище для метаданных файлов и информации о пользователях.
Хранилище файлов в локальной файловой директории.

## Поток данных и Практические Задачи:

### 1. Регистрация и Аутентификация (Auth Service)

· Эндпоинты: POST /api/auth/register, POST /api/auth/login.
· Технологии: ASP.NET Core, PostgreSQL, JWT.
· Задача: Реализовать хеширование паролей (BCrypt), генерацию JWT-токена. В токене хранить UserId.

### 2. Загрузка файла (Синхронно + Асинхронно)

· Поток:
  1. Клиент -> Yarp (POST /api/files/upload) с токеном и файлом.
  2. Yarp -> Auth Service (gRPC): проверка валидности токена.
  3. Yarp -> File Storage Service: загрузка файла. Сервис сохраняет файл и возвращает StorageFileId (например, путь к файлу).
  4. File Storage Service публикует сообщение в RabbitMQ: FileUploadedEvent (UserId, StorageFileId, OriginalName, Size).
  5. File Metadata Service (подписчик на RabbitMQ) получает событие и записывает метаданные в PostgreSQL.
  6. Клиенту возвращается ответ с ID файла и статусом "OK".
· Работа с IFormFile, публикация/потребление сообщений через RabbitMQ, транзакционность (если бы не было очереди).

### 3. Получение списка файлов пользователя

· Поток:
  1. Клиент -> Yarp (GET /api/files) с токеном.
  2. Yarp -> Auth Service (gRPC): проверка токена, получение UserId.
  3. Yarp -> File Metadata Service: запрос списка файлов по UserId.
  4. File Metadata Service сначала проверяет кеш Redis. Если нет, берет из PostgreSQL и кладет в Redis.
· Кеширование данных в Redis, gRPC-вызовы.

### 4. Скачивание файла (Главная фича с Yarp)

· Поток:
  1. Клиент -> Yarp (GET /api/files/download/{fileId}) с токеном.
  2. Yarp -> Auth Service (gRPC): проверка токена.
  3. Yarp -> File Metadata Service: проверка прав доступа (принадлежит ли файл пользователю?).
  4. Если все ОК, Yarp делает прозрачное проксирование (reverse proxy) запроса на File Storage Service (/storage/files/{fileId}).
  5. File Storage Service отдает файл напрямую клиенту через Yarp.
· Настройка маршрутов и трансформаций в Yarp для обхода основного бэкенда.
